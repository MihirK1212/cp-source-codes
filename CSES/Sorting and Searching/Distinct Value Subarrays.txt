#include<iostream>
#include<vector>
#include<string>
#include<map>
#include<cmath>
#include<set>
#include<queue>
#include<algorithm>
using namespace std;

#define f first
#define s second
#define pb push_back
#define printoneline(arr) for(long long i=0;i<arr.size();i++){cout<<arr[i]<<" ";} cout<<"\n";
#define all(x) (x).begin(), (x).end()
#define reverse(a) reverse(a.begin(),a.end());
#define input(arr) for(long long i=0;i<arr.size();i++){cin>>arr[i];}
#define cy cout<<"YES\n";
#define cn cout<<"NO\n";
#define cig cin.ignore();
typedef long long ll;
typedef long double ld;
typedef vector<long long> vll;
typedef vector<int> vi;
typedef vector<pair<ll,ll>> vpll;
typedef vector<pair<int,int>> vpii;
typedef pair<int,int> pii;
typedef pair<ll,ll> pll;
typedef pair<int,pair<int,int>> ppi;

ll inf=std::numeric_limits<long long>::max();

ll ceilVal(ll a,ll b) {
   return ceil(((ld)a)/((ld)b)); 
}

void setIO(string name = "") { 
    ios_base::sync_with_stdio(0); cin.tie(0); 
    if(name!="") {
        freopen((name+".in").c_str(), "r", stdin);
        freopen((name+".out").c_str(), "w", stdout);
    }
}

void solve() {
    ll n,i;
    cin>>n;
    vll a(n);
    input(a);

    ll start = 0, end = 0;
    
    ll countUnique = 1;

    map<ll, ll> freq;
    freq[a[0]]++;
    
    ll ans = 0;

    while(start<=end && end<n) {
        if(countUnique == (end-start+1)) {

            /*
            We can use sliding window to count subarray in these cases where if the 
            window along with the newly added element is valid, then all the
            subarrays ending at the newly added element index i.e. `end` are valid
            */
            ans+=(end-start+1);
            
            
            end++;
            if(end < n) {
                freq[a[end]]++;
                if(freq[a[end]] == 1){countUnique++;}
            }
        }
        else if(countUnique < (end-start + 1)) {
            if((start+1) <= end) {
                freq[a[start]]--;
                if(freq[a[start]] == 0){countUnique--;}
                start++;
            }
            else {
                throw logic_error("this is not possible! The start can never cross end since subarray of size 1 is always valid");
            }
        }
        else {
            throw logic_error("this is not possible! Number of unique elements cannot be more than size of window");
        }
    }

    cout<<ans<<"\n";
}

int main() {
    setIO("");
    ll T = 1;
    while(T--) {
        solve();
    }
    return 0;
}