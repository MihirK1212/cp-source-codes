#include <iostream>
#include <vector>
using namespace std;

const int MOD = 1e9 + 7;

class SegmentTree 
{
	vector<int> arr;
	int n;
	vector<long long> stSum;
	vector<long long> lazyIncrement, lazySet;
	vector<bool> hasLazySet;

	public:

	SegmentTree(vector<int>&arr) {
		this->arr = arr;
		this->n = arr.size();
		this->stSum = vector<long long>(4 * n, 0);
		this->lazyIncrement = vector<long long>(4*n, 0);
		this->lazySet = vector<long long>(4*n, 0);
		this->hasLazySet = vector<bool>(4*n, false);
		this->construct(0, 0, n-1);
	}

	void construct(int node, int nl, int nr) {
		if(nl==nr) {
			stSum[node] = arr[nl];
		} 
		else {
			int mid = nl + (nr - nl) / 2;
            construct(2 * node + 1, nl, mid);
            construct(2 * node + 2, mid + 1, nr);
            stSum[node] = stSum[2 * node + 1] + stSum[2 * node + 2];
		}
	}

	void lazyUpdateNode(int node, int nl, int nr) {
		if(hasLazySet[node]) {
			stSum[node] = (nr - nl + 1) * lazySet[node];
			if(nl != nr) {
				lazySet[2*node+1] = lazySet[node];
				lazySet[2*node + 2] = lazySet[node];
				hasLazySet[2 * node + 1] = true;
                hasLazySet[2 * node + 2] = true;

				lazyIncrement[2 * node + 1] = 0;
            	lazyIncrement[2 * node + 2] = 0;
			}
			lazySet[node] = 0;
			hasLazySet[node] = false;
		}
		if(lazyIncrement[node] != 0) {
			stSum[node] += (nr - nl + 1) * lazyIncrement[node];
			if(nl != nr) {
				lazyIncrement[2*node+1] += lazyIncrement[node];
				lazyIncrement[2*node+2] +=  lazyIncrement[node];
			}
			lazyIncrement[node] = 0;
		}
	}

	long long querySum(int node, int nl, int nr, int ql, int qr) {	
		lazyUpdateNode(node, nl, nr);

		if (ql > nr || qr < nl) {
			return 0;
		}

		if (ql <= nl && nr <= qr) {
			return stSum[node];
		}		

		// Partial overlap
        int mid = nl + (nr - nl) / 2;
        return querySum(2 * node + 1, nl, mid, ql, qr) +
               querySum(2 * node + 2, mid + 1, nr, ql, qr);
	}

	void updateIncrease(int node, int nl, int nr, int ql, int qr, int value) {
		lazyUpdateNode(node, nl, nr);

		if (ql > nr || qr < nl) {
			return;
		}

		if (ql <= nl && nr <= qr) {
			lazyIncrement[node] += value;
            lazyUpdateNode(node, nl, nr);
            return;
		}

		// Partial overlap
        int mid = nl + (nr - nl) / 2;
        updateIncrease(2 * node + 1, nl, mid, ql, qr, value);
        updateIncrease(2 * node + 2, mid + 1, nr, ql, qr, value);
        stSum[node] = stSum[2 * node + 1] + stSum[2 * node + 2];
	}

	void updateSet(int node, int nl, int nr, int ql, int qr, int value) {
		lazyUpdateNode(node, nl, nr);

		if (ql > nr || qr < nl) {
			return;
		}

		if (ql <= nl && nr <= qr) {
			lazySet[node] = value;
			hasLazySet[node] = true;
            lazyUpdateNode(node, nl, nr);
            return;
		}

		// Partial overlap
        int mid = nl + (nr - nl) / 2;
        updateSet(2 * node + 1, nl, mid, ql, qr, value);
        updateSet(2 * node + 2, mid + 1, nr, ql, qr, value);
        stSum[node] = stSum[2 * node + 1] + stSum[2 * node + 2];
	}
};


int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);

    int n, q;
    cin >> n >> q;

    vector<int> arr(n);
    for (auto &x : arr) {
        cin >> x;
    }

    SegmentTree st(arr);

    while (q--) {
        int type;
        cin >> type;

        if (type == 1) {
            int a, b, x;
            cin >> a >> b >> x;
            a--, b--;
            st.updateIncrease(0, 0, n - 1, a, b, x);
        } else if (type == 2) {
            int a, b, x;
            cin >> a >> b >> x;
            a--, b--;
            st.updateSet(0, 0, n - 1, a, b, x);
        } else if (type == 3) {
            int a, b;
            cin >> a >> b;
            a--, b--;
            cout << st.querySum(0, 0, n - 1, a, b) << "\n";
        }
    }

    return 0;
}